/*****************************************************************************\
 *                                                                           *
 * TestMethods.cpp                                                           *
 *                                                                           *
 * ------------------------------------------------------------------------- *
 * Copyright (C) 2007 Bryan Ischo <bryan@ischo.com>                          *
 *                                                                           *
 * This program is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU General Public License Version 2 as published  *
 * by the Free Software Foundation.                                          *
 *                                                                           *
 * This program is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General *
 * Public License for more details.                                          *
 *                                                                           *
 * You should have received a copy of the GNU General Public License         *
 * along with this program; if not, write to:                                *
 * The Free Software Foundation, Inc.                                        *
 * 51 Franklin Street, Fifth Floor                                           *
 * Boston, MA 02110-1301, USA.                                               *
 * ------------------------------------------------------------------------- *
 *                                                                           *
 * This test just makes sure that the constructor, destructor, method        *
 * invoker, getter, and setter methods generated by xrttigen work properly   *
 *                                                                           *
 \****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Xrtti/Xrtti.h>
#include <test/TestMethods.h>


using namespace Xrtti;

static const Method *LookupMethod(const Class &classRef, const char *name)
{
    ::u32 count = classRef.GetMethodCount();

    for (::u32 i = 0; i < count; i++) {
        const Method &method = classRef.GetMethod(i);
        if (!strcmp(method.GetName(), name)) {
            return &method;
        }
    }

    fprintf(stderr, "TestMethods has no %s method\n", name);
    exit(-1);

    return 0;
}


static const Field *LookupField(const Class &classRef, const char *name)
{
    ::u32 count = classRef.GetFieldCount();

    for (::u32 i = 0; i < count; i++) {
        const Field &field = classRef.GetField(i);
        if (!strcmp(field.GetName(), name)) {
            return &field;
        }
    }

    fprintf(stderr, "TestMethods has no %s field\n", name);
    exit(-1);

    return 0;
}


int main(int /* argc */, char ** /* argv */)
{
    const Context *pContext = LookupContext("TestMethods");

    if (!pContext) {
        fprintf(stderr, "Failed to lookup TestMethods Context\n");
        exit(-1);
    }

    if (pContext->GetType() != Context::Type_Class) {
        fprintf(stderr, "TestMethods Context is not a class\n");
        exit(-1);
    }

    const Class &classRef = * (const Class *) pContext;

    // Create one
    TestMethods *pCreated = (TestMethods *) classRef.Create();
    if (!pCreated) {
        fprintf(stderr, "TestMethods default constructor returned NULL\n");
        exit(-1);
    }

    // Invoke "Identify" method
    LookupMethod(classRef, "Identify")->Invoke(pCreated, NULL, NULL);

    // Invoke "Count" method repeatedly
    for (::u32 i = 0; i < 10; i++) {
        s16 ret;
        LookupMethod(classRef, "Count")->Invoke(pCreated, &ret, NULL);
        printf("TestMethods Count: %d\n", ret);
    }
    
    // Invoke "Sum" method
    {
        ::s32 ret;
        void *args[2];
        int arg1 = 1, arg2 = 2;
        args[0] = &arg1;
        args[1] = &arg2;
        LookupMethod(classRef, "Sum")->Invoke(pCreated, &ret, args);
        printf("TestMethods Sum: %d\n", ret);
    }

    // Invoke "Allocate" method
    {
        ::s32 *pAllocated;
        long arg1 = 5;
        void *args[1] = { &arg1 };
        LookupMethod(classRef, "Allocate")->Invoke(pCreated, &pAllocated, args);
        for (long i = 0; i < arg1; i++) {
            printf("TestMethods Allocate: %d\n", pAllocated[i]);
        }
        delete [] pAllocated;
    }

    // Invoke "GetInnerRef" method
    {
        TestMethods::Inner *pRet;
        LookupMethod(classRef, "GetInnerRef")->Invoke(pCreated, &pRet, NULL);
        printf("TestMethods::GetInnerRef a: %u, b: %f\n", 
                      pRet->a, pRet->b);
    }

    // Invoke "GetInnerCopy" method
    {
        TestMethods::Inner innerCopy;
        LookupMethod(classRef, "GetInnerCopy")->Invoke
            (pCreated, &innerCopy, NULL);
        printf("TestMethods::GetInnerCopy a: %u, b: %f\n", innerCopy.a, 
                      innerCopy.b);
    }

    // Invoke "TestParams" method
    {
        int arg1 = 1;
        float arg2 = 2.0;
        const char *arg3 = "3";
        TestMethods::Inner arg4 = { 4, 5.0 };
        TestMethods::Inner arg5val = { 6, 7.0 };
        TestMethods::Inner &arg5 = arg5val;
        TestMethods::Inner arg6val = { 8, 9.0 };
        TestMethods::Inner *arg6 = &arg6val;
        void *args[6] = { &arg1, &arg2, &arg3, &arg4, &arg5, &arg6 };
        LookupMethod(classRef, "TestParams")->Invoke(pCreated, NULL, args);
    }

    // Set "counterM" parameter
    {
        * ((s16 *) LookupField(classRef, "counterM")->Get(pCreated)) = 123;

        // Get "counterM" parameter
        printf
            ("TestMethods::Get counterM: %d\n",
             * ((s16 *) LookupField(classRef, "counterM")->Get(pCreated)));
    }

    {
        // Set "innerM" parameter
        TestMethods::Inner innerX;
        innerX.a = 901, innerX.b = 902.0;
        * ((TestMethods::Inner *) LookupField(classRef, "innerM")->
           Get(pCreated)) = innerX;
        innerX.a = 0, innerX.b = 0.0;
        innerX = * ((TestMethods::Inner *) LookupField(classRef, "innerM")->
                    Get(pCreated));
        printf("TestMethods::Get innerM a: %d, b: %f\n", 
                      innerX.a, innerX.b);
    }

    {
        TestMethods::Inner innerX;
        innerX.a = 1001, innerX.b = 1002.0;
        * ((TestMethods::Inner **) LookupField(classRef, "pInnerM")->
           Get(pCreated)) = &innerX;
        TestMethods::Inner *pInner = * ((TestMethods::Inner **) LookupField
                                        (classRef, "pInnerM")->Get(pCreated));
        printf("TestMethods::Get pInnerM a: %d, b: %f\n", 
                      pInner->a, pInner->b);
    }

    // Delete it
    classRef.Delete(pCreated);

    // Create array
    TestMethods *pResult = (TestMethods *) classRef.CreateArray(10);

    for (::u32 i = 0; i < 10; i++) {
        // Invoke "indentifer" method
        LookupMethod(classRef, "Identify")->Invoke(&(pResult[i]), NULL, NULL);
    }

    // Delete them
    classRef.DeleteArray(pResult);
    return 0;
}
